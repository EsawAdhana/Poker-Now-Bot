{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;AAAiG;AAC1F;AACP;AACA,YAAY,6CAAQ;AACpB,YAAY,0CAAK;AACjB;AACA,YAAY,yCAAI;AAChB;AACA;AACA;AACA,QAAQ,yCAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA,gBAAgB,iDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA,gBAAgB,+CAAU;AAC1B;AACA;AACA;AACA;AACO;AACP,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChEwC;AACiG;AAC5E;AACtD;AACP,2BAA2B,qDAAiB;AAC5C;AACA,uBAAuB,gEAAsB;AAC7C,0BAA0B,oEAA0B;AACpD,0BAA0B,gEAAsB;AAChD,6BAA6B,mEAAyB;AACtD,6BAA6B,6DAAmB;AAChD,wBAAwB,kDAAQ;AAChC,SAAS;AACT;AACA,WAAW,0EAAgB;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACf0D;AACnD;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,2CAAO;AACvE;AACA;AACA;AACA;AACA,kEAAkE,eAAe,qCAAqC,qBAAqB,MAAM,yDAAqB,EAAE,GAAG;AAC3K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,IAAI,2CAAO,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACnT0F;AACQ;AAC3F;AACP,0BAA0B,6DAAmB;AAC7C;AACA;AACA;AACA,SAAS;AACT,eAAe,4DAAc;AAC7B;AACA,iCAAiC,iEAAuB;AACxD,wBAAwB,wDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,4DAAc;AAC7B;AACA,eAAe,8DAAgB;AAC/B;AACA,eAAe,6DAAe;AAC9B,WAAW,4DAAc;AACzB;;;;;;;;;;;;;;;;;;;;;AC1ByC;AACqF;AACvH;AACP,WAAW,yEAAmB,CAAC,uEAAiB,wBAAwB,iEAAW;AACnF,uEAAuE,mDAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,WAAW,yEAAmB,CAAC,uEAAiB,0BAA0B,qEAAe;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,WAAW,yEAAmB,CAAC,uEAAiB,yBAAyB,qEAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,WAAW,yEAAmB,CAAC,uEAAiB,wBAAwB,qEAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,WAAW,yEAAmB,CAAC,uEAAiB,yBAAyB,qEAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;ACxFoD;AACS;AACqB;AAC3E;AACP,2BAA2B,mDAAe;AAC1C,YAAY,yEAA+B;AAC3C,gCAAgC,6CAAS;AACzC,uBAAuB,8DAAgB;AACvC;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA,mBAAmB,6DAAe;AAClC;AACA;AACA,WAAW;AACX;AACA,eAAe,6DAAe;AAC9B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnB0H;AAC/E;AACC;AACoB;AACd;AACR;AACO;AACC;AACN;AACI;AACzC;AACP,wBAAwB,gDAAY;AACpC,eAAe,8DAAa;AAC5B,oCAAoC,qDAAkB;AACtD,eAAe,4DAAc;AAC7B;AACA,aAAa,+CAAY;AACzB,mBAAmB,+DAAc;AACjC,aAAa,2CAAQ;AACrB,mBAAmB,uDAAU;AAC7B,aAAa,8CAAW;AACxB,mBAAmB,6DAAa;AAChC,aAAa,kDAAe;AAC5B,mBAAmB,yDAAW;AAC9B,aAAa,+CAAY;AACzB,mBAAmB,+DAAc;AACjC,aAAa,4CAAS;AACtB,mBAAmB,yDAAW;AAC9B;AACA,mBAAmB,6DAAe;AAClC;AACA;;;;;;;;;;;;;;;;;;;;;AC/BuC;AACE;AACgF;AACtB;AACjD;AAC3C;AACP,uBAAuB,kDAAQ;AAC/B;AACA,eAAe,+DAAc;AAC7B;AACA;AACO;AACP,mBAAmB,kDAAQ;AAC3B;AACA;AACA,6BAA6B,wDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,mDAAe;AAC1C,YAAY,yEAA+B;AAC3C;AACA,uBAAuB,8DAAgB;AACvC;AACA,uBAAuB,6DAAe;AACtC;AACA;AACA,gBAAgB,0EAAgC;AAChD;AACA,2BAA2B,4DAAc;AACzC;AACA,2BAA2B,6DAAe;AAC1C;AACA;AACA;AACA,2BAA2B,8DAAgB;AAC3C;AACA,2BAA2B,6DAAe;AAC1C;AACA,mBAAmB,4DAAc;AACjC;AACA;AACA,WAAW;AACX,YAAY,0EAAgC;AAC5C;AACA,uBAAuB,4DAAc;AACrC;AACA,uBAAuB,6DAAe;AACtC;AACA;AACA,mBAAmB,8DAAgB;AACnC,mDAAmD,4CAAQ;AAC3D,mBAAmB,6DAAe;AAClC;AACA,mBAAmB,4DAAc;AACjC;AACA,mBAAmB,6DAAe;AAClC;AACA;;;;;;;;;;;;;;;;;;;;ACrEqE;AACV;AAC5B;AAC+F;AAC/E;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAO;AAC5B,eAAe,4DAAc;AAC7B;AACA;AACA;AACA;AACA,WAAW,yEAAmB,uBAAuB,iEAAW;AAChE,8BAA8B,2CAAI;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,wDAAc;AACtC,uBAAuB,uDAAa;AACpC,iCAAiC,6CAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAAQ;AAC9C;AACA;AACA;AACA;AACA,kCAAkC,4CAAQ;AAC1C;AACA;AACA;AACA;AACA,WAAW,yEAAmB,CAAC,uEAAiB,gCAAgC,qEAAe;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,WAAW,yEAAmB,CAAC,uEAAiB,oCAAoC,qEAAe;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,WAAW,yEAAmB,CAAC,uEAAiB,wCAAwC,qEAAe;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,uBAAuB,uDAAa;AACpC;AACA;AACA,uBAAuB,2CAAI;AAC3B,WAAW,yEAAmB,CAAC,uEAAiB,iCAAiC,qEAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,WAAW,yEAAmB,CAAC,uEAAiB,iCAAiC,qEAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,WAAW,yEAAmB,CAAC,uEAAiB,4BAA4B,qEAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACjK2F;AACT;AAC3E;AACP,QAAQ,gEAAsB;AAC9B,eAAe,4DAAc;AAC7B,uBAAuB,0DAAgB;AACvC,4BAA4B,6DAAmB;AAC/C;AACA;AACA,eAAe,6DAAe;AAC9B,WAAW,8DAAgB;AAC3B;;;;;;;;;;;;;;;;;;;;ACXgD;AACP;AAC6F;AACpD;AAChC;AAC3C;AACP,mBAAmB,qDAAW;AAC9B;AACA,uBAAuB,wDAAc;AACrC,kCAAkC,2CAAO;AACzC,mBAAmB,4DAAc;AACjC,uCAAuC,4CAAQ;AAC/C,mBAAmB,8DAAgB;AACnC;AACA,mBAAmB,+DAAc;AACjC;AACA,QAAQ,0EAAgC;AACxC,eAAe,6DAAe;AAC9B,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT,eAAe,8DAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,4CAAQ;AACrC,eAAe,8DAAgB;AAC/B,4BAA4B,mDAAe;AAC3C,YAAY,yEAA+B;AAC3C,mBAAmB,8DAAgB;AACnC;AACA,WAAW,6DAAe;AAC1B;;;;;;;;;;;;;;;;;;;ACxCwE;AACP;AACf;AACS;AACpD;AACP,uBAAuB,kDAAQ;AAC/B;AACA;AACA,mBAAmB,wEAA2B;AAC9C;AACA,mBAAmB,+DAAc;AACjC;AACA,QAAQ,0EAAgC;AACxC,eAAe,4DAAc;AAC7B,WAAW,8DAAgB;AAC3B;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,uBAAuB;AACnD,uBAAuB,cAAc;AACrC,2BAA2B,mCAAmC;AAC9D,+BAA+B,uCAAuC;AACtE,gCAAgC,uCAAuC;AACvE,2BAA2B,mCAAmC;AAC9D,6BAA6B,uCAAuC;AACpE,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yCAAyC,gBAAgB,oBAAoB;AAC7E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtJO;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjEO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BsE;AAC/B;AACW;AAC3C;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAqB;AAC3C,SAAS,4DAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,WAAW,oDAAa;AACxB;AACO;AACP;AACA,WAAW,+DAAuB;AAClC;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;;;;;;;UC/KA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNoC;AAC4C;AACvB;AACzD;AACA;AACA,0BAA0B,qCAAqC;AAC/D;AACA;AACA;AACA,gCAAgC,qDAAgB;AAChD;AACA,YAAY,6CAAQ;AACpB;AACA,0BAA0B,6CAAQ;AAClC;AACA;AACA;AACA,yBAAyB,iDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAc;AAClD;AACA,YAAY,sDAAa;AACzB;AACA;AACA;AACA;AACA,QAAQ,uDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://pokernow-bot/./src/action.ts","webpack://pokernow-bot/./src/ai/ai.ts","webpack://pokernow-bot/./src/ai/aiUtils.ts","webpack://pokernow-bot/./src/ai/ifThenElse/flushAction.ts","webpack://pokernow-bot/./src/ai/ifThenElse/handActions.ts","webpack://pokernow-bot/./src/ai/ifThenElse/highCardAction.ts","webpack://pokernow-bot/./src/ai/ifThenElse/ifThenElseAi.ts","webpack://pokernow-bot/./src/ai/ifThenElse/pairAction.ts","webpack://pokernow-bot/./src/ai/ifThenElse/preflopActions.ts","webpack://pokernow-bot/./src/ai/ifThenElse/straightAction.ts","webpack://pokernow-bot/./src/ai/ifThenElse/threeAction.ts","webpack://pokernow-bot/./src/ai/ifThenElse/twoPairAction.ts","webpack://pokernow-bot/./src/ai/lerp.ts","webpack://pokernow-bot/./src/ai/probabilisticAction.ts","webpack://pokernow-bot/./src/cards.ts","webpack://pokernow-bot/./src/rank.ts","webpack://pokernow-bot/./src/state.ts","webpack://pokernow-bot/./src/ui.ts","webpack://pokernow-bot/webpack/bootstrap","webpack://pokernow-bot/webpack/runtime/define property getters","webpack://pokernow-bot/webpack/runtime/hasOwnProperty shorthand","webpack://pokernow-bot/webpack/runtime/make namespace object","webpack://pokernow-bot/./src/main.ts"],"sourcesContent":["import { allInRaise, call, canCheck, check, fold, halfPotRaise, minRaise, potRaise } from \"./ui\";\nexport function performAction(action, callback) {\n    if (action.type === \"check_or_fold\") {\n        if (canCheck())\n            check();\n        else\n            fold();\n        callback === null || callback === void 0 ? void 0 : callback();\n    }\n    else if (action.type === \"call\") {\n        call();\n        callback === null || callback === void 0 ? void 0 : callback();\n    }\n    else {\n        switch (action.raiseAmount) {\n            case \"min\":\n            default:\n                minRaise(callback);\n                break;\n            case \"1/2_pot\":\n                halfPotRaise(callback);\n                break;\n            // TODO: usare 3/4 pot?\n            // case \"3/4_pot\":\n            //     tqPotRaise(callback);\n            //     break;\n            case \"pot\":\n                potRaise(callback);\n                break;\n            // TODO: usare overbet?\n            case \"all_in\":\n                allInRaise(callback);\n                break;\n        }\n    }\n}\nexport function sanitizeAction(action, state) {\n    let sanitized = Object.assign({}, action);\n    switch (sanitized.type) {\n        case \"check_or_fold\":\n        case \"call\":\n        case \"raise\":\n            // ok, no problem here\n            break;\n        default:\n            sanitized.type = \"check_or_fold\";\n            break;\n    }\n    if (sanitized.type === \"raise\") {\n        switch (sanitized.raiseAmount) {\n            case \"min\":\n            case \"1/2_pot\":\n            // case \"3/4_pot\":\n            case \"pot\":\n            // case \"overbet\":\n            case \"all_in\":\n                // ok, no problem here\n                break;\n            default:\n                sanitized.raiseAmount = \"min\";\n                break;\n        }\n    }\n    return sanitized;\n}\n","import { PreflopPhase } from \"../state\";\nimport { findBestGapStraight, getPairs, isOneCardFlushPossible, isOneCardStraightPossible, isOpenEndedStraightPresent } from \"./aiUtils\";\nimport { ifThenElseAction } from \"./ifThenElse/ifThenElseAi\";\nexport function getAction(state) {\n    if (state.phase.code > PreflopPhase.code) {\n        console.log(\"stats\", {\n            flushDraw: isOneCardFlushPossible(state.handPlusBoard),\n            openStraight: isOpenEndedStraightPresent(state.handPlusBoard),\n            oneCardFlush: isOneCardFlushPossible(state.board),\n            oneCardStraight: isOneCardStraightPossible(state.board),\n            bestGapStraight: findBestGapStraight(state.board),\n            boardPairs: getPairs(state.board),\n        });\n    }\n    return ifThenElseAction(state);\n}\n","import { AceCode, LowestStraightAceCode } from \"../cards\";\nexport function isOneCardFlushOrStraightPossible(cards) {\n    return isOneCardFlushPossible(cards) || isOneCardStraightPossible(cards);\n}\nexport function hasFlushDrawOrOpenEndedStraight(cards) {\n    return isOneCardFlushPossible(cards) || isOpenEndedStraightPresent(cards);\n}\n/**\n * Is only one more card needed for a flush?\n * In other words returns if there are four cards of the same suit.\n */\nexport function isOneCardFlushPossible(cards) {\n    const counts = {};\n    for (const c of cards) {\n        if (!counts[c.suit])\n            counts[c.suit] = 1;\n        else\n            counts[c.suit] += 1;\n    }\n    for (const suit in counts)\n        if (counts[suit] === 4)\n            return true;\n    return false;\n}\n/**\n * Is only one more card needed for a straight?\n */\nexport function isOneCardStraightPossible(cards) {\n    if (isSimpleOneCardStraightPossible(cards))\n        return true;\n    if (cards.length < 4)\n        return false;\n    const lowestAceCards = useSortedLowestAce(cards);\n    if (lowestAceCards === null)\n        return false;\n    return isSimpleOneCardStraightPossible(lowestAceCards);\n}\nfunction useLowestAce(cards) {\n    const firstAceIndex = cards.findIndex(c => c.value.code === AceCode);\n    if (firstAceIndex < 0)\n        return null;\n    const firstAce = cards[firstAceIndex];\n    const lowestAceCards = [...cards];\n    lowestAceCards[firstAceIndex] = Object.assign(Object.assign({}, firstAce), { value: Object.assign(Object.assign({}, firstAce.value), { code: LowestStraightAceCode }) });\n    return lowestAceCards;\n}\nfunction useSortedLowestAce(cards) {\n    const lowestAceCards = useLowestAce(cards);\n    if (lowestAceCards === null)\n        return null;\n    return sortInPlaceAscending(lowestAceCards);\n}\n/**\n * Simple because it does not account for A in both A2345 and TJQKA\n */\nfunction isSimpleOneCardStraightPossible(cards) {\n    if (cards.length < 4)\n        return false;\n    const sorted = sortInPlaceAscendingRemovingDuplicates([...cards]);\n    const gapStraight = simpleFindFirstGapStraightOnSortedCards(sorted);\n    return gapStraight !== null;\n}\n/**\n * Simple because it does not account for A in both A2345 and TJQKA\n */\nfunction simpleFindFirstGapStraightOnSortedCards(sorted, startIndex = 0) {\n    const consecutives = findFirstConsecutives(sorted, startIndex);\n    if (consecutives === null)\n        return null;\n    if (consecutives.count >= 4)\n        return { firstPiece: consecutives };\n    if (consecutives.count === 2) {\n        const followingConsecutives = findFirstConsecutives(sorted, consecutives.startIndex + consecutives.count);\n        if (followingConsecutives === null)\n            return null;\n        if (consecutives.min.value.code + 3 === followingConsecutives.min.value.code) {\n            return {\n                firstPiece: consecutives,\n                secondPiece: followingConsecutives,\n            };\n        }\n        return null;\n    }\n    // consecutives count is 3\n    if (consecutives.startIndex > 0) {\n        if (consecutives.min.value.code === sorted[consecutives.startIndex - 1].value.code + 2) {\n            return {\n                firstPiece: {\n                    startIndex: consecutives.startIndex - 1,\n                    count: 1,\n                    min: sorted[consecutives.startIndex - 1],\n                },\n                secondPiece: consecutives,\n            };\n        }\n    }\n    if (consecutives.startIndex + 3 < sorted.length) {\n        if (consecutives.min.value.code + 4 === sorted[consecutives.startIndex + 3].value.code) {\n            return {\n                firstPiece: consecutives,\n                secondPiece: {\n                    startIndex: consecutives.startIndex + 3,\n                    count: 1,\n                    min: sorted[consecutives.startIndex + 3],\n                },\n            };\n        }\n    }\n    return null;\n}\n/**\n * A gap straight is one that is missing one of the 5 cards\n */\nexport function findBestGapStraight(cards) {\n    if (cards.length < 4)\n        return null;\n    const sorted = sortInPlaceAscendingRemovingDuplicates([...cards]);\n    for (let i = cards.length - 4; i >= 0; i--) {\n        const gapStraight = simpleFindFirstGapStraightOnSortedCards(sorted, i);\n        if (gapStraight !== null)\n            return gapStraight;\n    }\n    const lowestAceCards = useSortedLowestAce(sorted);\n    if (lowestAceCards === null)\n        return null;\n    const lowestGapStraight = simpleFindFirstGapStraightOnSortedCards(lowestAceCards);\n    return lowestGapStraight;\n}\n/**\n * Is there an open ended straight in these cards?\n * An open ended straight is one where either the top or bottom card is missing,\n * for instance 8,7,6,5 is an open ended straight because it's missing either a 9 or a 4\n */\nexport function isOpenEndedStraightPresent(cards) {\n    if (cards.length < 4)\n        return false;\n    const sorted = sortInPlaceAscendingRemovingDuplicates([...cards]);\n    const consecutives = findFirstConsecutives(sorted, 0);\n    if (consecutives === null)\n        return false;\n    return consecutives.count >= 4;\n}\nexport function findBestStraight(cards) {\n    if (cards.length < 5)\n        return null;\n    const sorted = sortInPlaceAscendingRemovingDuplicates([...cards]);\n    for (let i = sorted.length - 5; i >= 0; i--) {\n        const straight = findFirstStraightOnSortedCards(sorted, i);\n        if (straight !== null)\n            return straight;\n    }\n    return null;\n}\nexport function findFirstStraight(cards, startIndex = 0) {\n    if (cards.length < 5)\n        return null;\n    const sorted = sortInPlaceAscendingRemovingDuplicates([...cards]);\n    return findFirstStraightOnSortedCards(sorted, startIndex);\n}\nfunction findFirstStraightOnSortedCards(sorted, startIndex = 0) {\n    const straight = simpleFindFirstStraightOnSortedCards(sorted, startIndex);\n    if (straight !== null)\n        return straight;\n    if (sorted.length < 5 || startIndex > 0)\n        return null;\n    const lowestAceCards = useSortedLowestAce(sorted);\n    if (lowestAceCards === null)\n        return null;\n    sortInPlaceAscending(lowestAceCards);\n    return simpleFindFirstStraightOnSortedCards(lowestAceCards);\n}\n/**\n * Simple because it does not account for A in both A2345 and TJQKA\n */\nfunction simpleFindFirstStraightOnSortedCards(sorted, startIndex = 0) {\n    if (sorted.length < 5)\n        return null;\n    for (let i = startIndex; i < sorted.length - 5; i++) {\n        const consecutives = findFirstConsecutives(sorted, i);\n        if (consecutives !== null && consecutives.count >= 5)\n            return consecutives;\n    }\n    return null;\n}\nexport function findFirstConsecutives(sortedCards, startIndex = 0) {\n    if (sortedCards.length - startIndex < 2)\n        return null;\n    const consecutives = {\n        startIndex,\n        count: 1,\n        min: sortedCards[startIndex],\n    };\n    for (let i = startIndex + 1; i < sortedCards.length; i++) {\n        if (sortedCards[i].value.code === consecutives.min.value.code + consecutives.count) {\n            consecutives.count += 1;\n        }\n        else if (consecutives.count === 1) {\n            consecutives.startIndex = i;\n            consecutives.min = sortedCards[i];\n        }\n        else {\n            return consecutives;\n        }\n    }\n    if (consecutives.count > 1)\n        return consecutives;\n    return null;\n}\nexport function getSuitCounts(cards) {\n    const counts = {};\n    for (const c of cards) {\n        if (!counts[c.suit])\n            counts[c.suit] = [c];\n        else\n            counts[c.suit].push(c);\n    }\n    return counts;\n}\nexport function getHighestSuitCount(cards) {\n    const counts = getSuitCounts(cards);\n    let max = null;\n    for (const suit in counts)\n        if (max === null || max.length < counts[suit].length)\n            max = counts[suit];\n    return max;\n}\nexport function getAvailableFlushValues(suitedCards) {\n    const available = [];\n    for (let i = 2; i < AceCode; i++)\n        available.push(i);\n    for (const c of suitedCards) {\n        const index = available.indexOf(c.value.code);\n        if (index >= 0)\n            available.splice(index, 1);\n    }\n    return available;\n}\nexport function getFirstOfSuit(cards, suit) {\n    for (const c of cards)\n        if (c.suit === suit)\n            return c;\n    return null;\n}\nexport function getValueCounts(cards) {\n    const counts = {};\n    for (const c of cards) {\n        if (!counts[c.value.code])\n            counts[c.value.code] = [c];\n        else\n            counts[c.value.code].push(c);\n    }\n    return counts;\n}\n/**\n * If `n === 2` then this is equal to @see getPairs\n */\nexport function getNs(cards, n) {\n    const counts = getValueCounts(cards);\n    const ns = [];\n    for (const key in counts) {\n        const counted = counts[key];\n        if (counted.length === n)\n            ns.push(counted);\n    }\n    return ns;\n}\n/**\n * Returns a list of all pairs in `cards`\n */\nexport function getPairs(cards) {\n    const pairs = getNs(cards, 2);\n    return pairs;\n}\n/**\n * Returns a list of all triplets (three cards of the same value) in `cards`\n */\nexport function getTriplets(cards) {\n    const threes = getNs(cards, 3);\n    return threes;\n}\nexport function getHighestCard(cards) {\n    let max = null;\n    for (const c of cards)\n        if (max === null || c.value.code > max.value.code)\n            max = c;\n    return max;\n}\nexport function getLowestCard(cards) {\n    let min = null;\n    for (const c of cards)\n        if (min === null || c.value.code < min.value.code)\n            min = c;\n    return min;\n}\nexport function sortInPlaceAscending(cards) {\n    return cards.sort((c1, c2) => c1.value.code - c2.value.code);\n}\nexport function removeSortedDuplicateValuesInPlace(cards) {\n    for (let i = 0; i < cards.length - 1; i++) {\n        while (i + 1 < cards.length && cards[i].value.code === cards[i + 1].value.code)\n            cards.splice(i, 1);\n    }\n    return cards;\n}\nexport function sortInPlaceAscendingRemovingDuplicates(cards) {\n    const sorted = sortInPlaceAscending(cards);\n    return removeSortedDuplicateValuesInPlace(sorted);\n}\n","import { getAvailableFlushValues, getFirstOfSuit, getHighestSuitCount } from \"../aiUtils\";\nimport { bestHandAction, riskyHandAction, strongHandAction, weakHandAction } from \"./handActions\";\nexport function flushAction(state) {\n    const mostSuitCards = getHighestSuitCount(state.board);\n    if (mostSuitCards.length === 3) {\n        console.log(\"flush state\", {\n            mostSuitCards,\n        });\n        return bestHandAction(state);\n    }\n    const availableFlushValues = getAvailableFlushValues(mostSuitCards);\n    const myFlushCard = getFirstOfSuit(state.hand, mostSuitCards[0].suit);\n    const index = availableFlushValues.indexOf(myFlushCard.value.code);\n    console.log(\"flush state\", {\n        mostSuitCards,\n        availableFlushValues,\n        myFlushCard,\n        index,\n    });\n    if (index === availableFlushValues.length - 1)\n        return bestHandAction(state);\n    if (index === availableFlushValues.length - 2)\n        return strongHandAction(state);\n    if (index > 4)\n        return riskyHandAction(state);\n    return weakHandAction(state);\n}\n","import { RiverPhase } from \"../../state\";\nimport { probabilisticAction, postfixNameToCall, toCallDependent, uniformFill, checkCallBased } from \"../probabilisticAction\";\nexport function bestHandAction(state) {\n    return probabilisticAction(postfixNameToCall(\"best\", state), state, uniformFill({\n        checkFoldProbability: state.toCall === 0 && state.phase.code < RiverPhase.code\n            ? undefined\n            : 0,\n        minRaiseProbability: 0.3,\n        halfPotRaiseProbability: 0.25,\n        potRaiseProbability: 0.15,\n        allInProbability: 0.05,\n    }));\n}\nexport function strongHandAction(state) {\n    return probabilisticAction(postfixNameToCall(\"strong\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.2,\n            minRaiseProbability: 0.4,\n            halfPotRaiseProbability: 0.25,\n            potRaiseProbability: 0.12,\n            allInProbability: 0.03,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: Math.min(0.05 * (state.toCall / state.prevPhasePot), 0.1),\n            callProbability: Math.min(0.5 * (state.toCall / state.prevPhasePot), 0.65),\n            remainingMinRaiseShare: 0.4,\n            remainingHalfPotRaiseShare: 0.33,\n            remainingPotRaiseShare: 0.24,\n            remainingAllInShare: 0.03,\n        }),\n    }));\n}\nexport function riskyHandAction(state) {\n    return probabilisticAction(postfixNameToCall(\"risky\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.3,\n            minRaiseProbability: 0.42,\n            halfPotRaiseProbability: 0.17,\n            potRaiseProbability: 0.09,\n            allInProbability: 0.02,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: Math.min(0.4 * (state.toCall / state.prevPhasePot), 0.2),\n            callProbability: Math.min(1.1 * (state.toCall / state.prevPhasePot), 0.6),\n            remainingMinRaiseShare: 0.4,\n            remainingHalfPotRaiseShare: 0.33,\n            remainingPotRaiseShare: 0.24,\n            remainingAllInShare: 0.03,\n        }),\n    }));\n}\nexport function weakHandAction(state) {\n    return probabilisticAction(postfixNameToCall(\"weak\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.4,\n            minRaiseProbability: 0.1,\n            halfPotRaiseProbability: 0.27,\n            potRaiseProbability: 0.2,\n            allInProbability: 0.03,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: Math.min(2 * (state.toCall / state.prevPhasePot), 0.5),\n            callProbability: (1 - (state.toCall / state.prevPhasePot)) * 0.2,\n            remainingMinRaiseShare: 0.2,\n            remainingHalfPotRaiseShare: 0.32,\n            remainingPotRaiseShare: 0.38,\n            remainingAllInShare: 0.1,\n        }),\n    }));\n}\nexport function bluffHandAction(state) {\n    return probabilisticAction(postfixNameToCall(\"bluff\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.7,\n            minRaiseProbability: 0.1,\n            halfPotRaiseProbability: 0.07,\n            potRaiseProbability: 0.1,\n            allInProbability: 0.03,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: Math.min(2 * (state.toCall / state.prevPhasePot), 0.7),\n            callProbability: 0.1,\n            remainingMinRaiseShare: 0.15,\n            remainingHalfPotRaiseShare: 0.32,\n            remainingPotRaiseShare: 0.43,\n            remainingAllInShare: 0.1,\n        }),\n    }));\n}\n","import { FlopPhase, RiverPhase } from \"../../state\";\nimport { hasFlushDrawOrOpenEndedStraight } from \"../aiUtils\";\nimport { bluffHandAction, strongHandAction, weakHandAction } from \"./handActions\";\nexport function highCardAction(state) {\n    if (state.phase.code < RiverPhase.code) {\n        if (hasFlushDrawOrOpenEndedStraight(state.handPlusBoard)) {\n            if (state.phase === FlopPhase)\n                return strongHandAction(state);\n            else // turn\n                return weakHandAction(state);\n        }\n        else {\n            return bluffHandAction(state);\n        }\n    }\n    else { // river\n        // TODO: se l'avversario ha solo checkato raise more likely\n        return bluffHandAction(state);\n    }\n}\n","import { FlushRank, FullHouseRank, HighCardRank, PairRank, StraightRank, ThreeOfKindRank, TwoPairRank } from \"../../rank\";\nimport { PreflopPhase } from \"../../state\";\nimport { flushAction } from \"./flushAction\";\nimport { bestHandAction, bluffHandAction } from \"./handActions\";\nimport { highCardAction } from \"./highCardAction\";\nimport { pairAction } from \"./pairAction\";\nimport { preflopAction } from \"./preflopActions\";\nimport { straightAction } from \"./straightAction\";\nimport { threeAction } from \"./threeAction\";\nimport { twoPairAction } from \"./twoPairAction\";\nexport function ifThenElseAction(state) {\n    if (state.phase === PreflopPhase)\n        return preflopAction(state);\n    else if (state.handRank.code >= FullHouseRank.code)\n        return bestHandAction(state);\n    switch (state.handRank) {\n        case HighCardRank:\n            return highCardAction(state);\n        case PairRank:\n            return pairAction(state);\n        case TwoPairRank:\n            return twoPairAction(state);\n        case ThreeOfKindRank:\n            return threeAction(state);\n        case StraightRank:\n            return straightAction(state);\n        case FlushRank:\n            return flushAction(state);\n        default:\n            return bluffHandAction(state);\n    }\n}\n","import { KingCode } from \"../../cards\";\nimport { RiverPhase } from \"../../state\";\nimport { getHighestCard, getPairs, hasFlushDrawOrOpenEndedStraight, isOneCardFlushOrStraightPossible } from \"../aiUtils\";\nimport { bluffHandAction, riskyHandAction, strongHandAction, weakHandAction } from \"./handActions\";\nimport { highCardAction } from \"./highCardAction\";\nexport function pairAction(state) {\n    const boardPairs = getPairs(state.board);\n    if (boardPairs.length > 0)\n        return highCardAction(state);\n    return pairActionIgnoringBoardPair(state);\n}\nexport function pairActionIgnoringBoardPair(state) {\n    const myPair = getPairs(state.handPlusBoard)[0];\n    if (!myPair || myPair.length === 0)\n        throw new Error(\"pair expected but not found \" + JSON.stringify(state.handPlusBoard, null, 4));\n    const highestBoardCard = getHighestCard(state.board);\n    const isTopPair = myPair[0].value.code >= highestBoardCard.value.code;\n    const isHandPair = state.hand[0].value.code === state.hand[1].value.code;\n    const kicker = !isHandPair\n        ? state.hand[0].value.code !== myPair[0].value.code\n            ? state.hand[0]\n            : state.hand[1]\n        : highestBoardCard;\n    console.log(\"pair hand state\", {\n        myPair,\n        highestBoardCard,\n        isTopPair,\n        isHandPair,\n        kicker,\n    });\n    if (state.phase.code < RiverPhase.code) {\n        if (hasFlushDrawOrOpenEndedStraight(state.handPlusBoard)) {\n            if (isTopPair)\n                return strongHandAction(state);\n            else\n                return riskyHandAction(state);\n        }\n        else {\n            if (isOneCardFlushOrStraightPossible(state.board)) {\n                if (isTopPair)\n                    return weakHandAction(state);\n                else\n                    return bluffHandAction(state);\n            }\n            if (isTopPair) {\n                if (isHandPair)\n                    return strongHandAction(state);\n                else\n                    return riskyHandAction(state);\n            }\n            return weakHandAction(state);\n        }\n    }\n    else { // river\n        if (isOneCardFlushOrStraightPossible(state.board)) {\n            if (isTopPair)\n                return weakHandAction(state);\n            else\n                return bluffHandAction(state);\n        }\n        if (isTopPair && isHandPair)\n            return strongHandAction(state);\n        else if (isTopPair && kicker.value.code >= KingCode)\n            return riskyHandAction(state);\n        else if (isTopPair)\n            return weakHandAction(state);\n        else\n            return bluffHandAction(state);\n    }\n}\n","import { AceCode, JackCode, KingCode, QueenCode } from \"../../cards\";\nimport { getHighestCard, getLowestCard } from \"../aiUtils\";\nimport { lerp } from \"../lerp\";\nimport { checkCallBased, postfixNameToCall, probabilisticAction, toCallDependent, uniformFill } from \"../probabilisticAction\";\nimport { bestHandAction } from \"./handActions\";\nexport function preflopAction(state) {\n    const hasPair = state.hand[0].value.code === state.hand[1].value.code;\n    if (hasPair)\n        return pairPreflopAction(state);\n    else\n        return nonPairPreflopAction(state);\n}\nfunction pairPreflopAction(state) {\n    const valueCode = state.hand[0].value.code;\n    if (valueCode == AceCode)\n        return bestHandAction(state);\n    if (valueCode >= 10)\n        return highPairAction(state);\n    const ninesCheckOrFoldProbability = 0.05;\n    const twosCheckOrFoldProbability = 0.8;\n    return probabilisticAction(\"pre-lowpair\", state, uniformFill({\n        checkFoldProbability: lerp(twosCheckOrFoldProbability, ninesCheckOrFoldProbability, (valueCode - 2) / 9),\n        halfPotRaiseProbability: 0,\n        allInProbability: 0,\n    }));\n}\nfunction nonPairPreflopAction(state) {\n    const highestCard = getHighestCard(state.hand);\n    const lowestCard = getLowestCard(state.hand);\n    if (lowestCard.value.code >= QueenCode)\n        return premiumNonPairAction(state);\n    if (lowestCard.value.code >= 10)\n        return semiHighNonPairAction(state);\n    const delta = highestCard.value.code - lowestCard.value.code;\n    if (delta >= 5) {\n        if (highestCard.value.code >= KingCode)\n            return highTrashAction(state);\n        else\n            return pureTrashAction(state);\n    }\n    if (highestCard.value.code >= JackCode)\n        return faceAction(state);\n    return pureTrashAction(state);\n}\nfunction highPairAction(state) {\n    return probabilisticAction(postfixNameToCall(\"pre-highpair\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0,\n            minRaiseProbability: 0.5,\n            halfPotRaiseProbability: 0,\n            potRaiseProbability: 0.5,\n            allInProbability: 0,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0,\n            callProbability: (state.pot >= 3 * state.bigBlind) ? 0.5 : 0,\n            remainingMinRaiseShare: 0.5,\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: 0.5,\n            remainingAllInShare: 0,\n        }),\n    }));\n}\nfunction premiumNonPairAction(state) {\n    return probabilisticAction(postfixNameToCall(\"pre-high-nonpair\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0,\n            minRaiseProbability: 0.6,\n            halfPotRaiseProbability: 0,\n            potRaiseProbability: 0.4,\n            allInProbability: 0,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0,\n            callProbability: (state.pot >= 3 * state.bigBlind) ? 0.5 : 0,\n            remainingMinRaiseShare: 0.7,\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: 0.3,\n            remainingAllInShare: 0,\n        }),\n    }));\n}\nfunction semiHighNonPairAction(state) {\n    return probabilisticAction(postfixNameToCall(\"pre-semihigh-nonpair\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0,\n            minRaiseProbability: 0.8,\n            halfPotRaiseProbability: 0,\n            potRaiseProbability: 0.2,\n            allInProbability: 0,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0,\n            callProbability: (state.pot >= 3 * state.bigBlind) ? 0.7 : 0,\n            remainingMinRaiseShare: 0.8,\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: 0.2,\n            remainingAllInShare: 0,\n        }),\n    }));\n}\nfunction highTrashAction(state) {\n    const lowestCard = getLowestCard(state.hand);\n    const twoMultiplier = 0.3;\n    const nineMultiplier = 1;\n    const multiplier = lerp(twoMultiplier, nineMultiplier, (lowestCard.value.code - 2) / 7);\n    return probabilisticAction(postfixNameToCall(\"pre-hightrash\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.7,\n            minRaiseProbability: 0.2,\n            halfPotRaiseProbability: 0.1,\n            potRaiseProbability: 0,\n            allInProbability: 0,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0.6,\n            callProbability: multiplier * ((state.pot > state.bigBlind && state.pot <= 4 * state.bigBlind) ? 0.2 : 0.05),\n            remainingMinRaiseShare: multiplier * (state.pot <= 4 * state.bigBlind ? 0.2 : 0.05),\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: 0,\n            remainingAllInShare: 0,\n        }),\n    }));\n}\nfunction pureTrashAction(state) {\n    return probabilisticAction(postfixNameToCall(\"pre-puretrash\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.98,\n            minRaiseProbability: 0,\n            halfPotRaiseProbability: 0,\n            potRaiseProbability: 0,\n            allInProbability: 0.02,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0.85,\n            callProbability: (state.pot <= 3 * state.bigBlind) ? 0.07 : 0,\n            remainingMinRaiseShare: (state.pot < 3 * state.bigBlind) ? 0.06 : 0,\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: (state.pot >= 3 * state.bigBlind) ? 0.13 : 0,\n            remainingAllInShare: 0.02,\n        }),\n    }));\n}\nfunction faceAction(state) {\n    return probabilisticAction(postfixNameToCall(\"pre-face\", state), state, toCallDependent(state, {\n        zero: {\n            checkFoldProbability: 0.7,\n            minRaiseProbability: 0.2,\n            halfPotRaiseProbability: 0.1,\n            potRaiseProbability: 0,\n            allInProbability: 0,\n        },\n        nonZero: checkCallBased({\n            checkFoldProbability: 0.6,\n            callProbability: (state.pot > state.bigBlind && state.pot <= 4 * state.bigBlind) ? 0.2 : 0.05,\n            remainingMinRaiseShare: (state.pot <= 4 * state.bigBlind) ? 0.2 : 0.05,\n            remainingHalfPotRaiseShare: 0,\n            remainingPotRaiseShare: 0,\n            remainingAllInShare: 0,\n        }),\n    }));\n}\n","import { findBestGapStraight, findBestStraight, isOneCardFlushPossible } from \"../aiUtils\";\nimport { riskyHandAction, strongHandAction, weakHandAction } from \"./handActions\";\nexport function straightAction(state) {\n    if (isOneCardFlushPossible(state.board))\n        return weakHandAction(state);\n    const myStraight = findBestStraight(state.handPlusBoard);\n    const bestGapStraight = findBestGapStraight(state.board);\n    const isBetterStraightPossible = bestGapStraight !== null && myStraight.min.value.code < bestGapStraight.firstPiece.min.value.code;\n    if (isBetterStraightPossible)\n        return riskyHandAction(state);\n    return strongHandAction(state);\n}\n","import { AceCode, KingCode } from \"../../cards\";\nimport { RiverPhase } from \"../../state\";\nimport { getHighestCard, getPairs, getTriplets, hasFlushDrawOrOpenEndedStraight, isOneCardFlushOrStraightPossible } from \"../aiUtils\";\nimport { bestHandAction, riskyHandAction, strongHandAction } from \"./handActions\";\nimport { highCardAction } from \"./highCardAction\";\nexport function threeAction(state) {\n    const threes = getTriplets(state.board);\n    if (threes.length !== 0) {\n        const kicker = getHighestCard(state.hand);\n        if (kicker.value.code === AceCode)\n            return bestHandAction(state);\n        else if (kicker.value.code === KingCode)\n            return strongHandAction(state);\n        else\n            return highCardAction(state);\n    }\n    if (isOneCardFlushOrStraightPossible(state.board))\n        return riskyHandAction(state);\n    const boardPair = getPairs(state.board)[0];\n    const isSet = !boardPair;\n    if (isSet) {\n        console.log(\"three state\", {\n            isSet,\n        });\n        return strongHandAction(state);\n    }\n    const kicker = boardPair[0].value.code === state.hand[0].value.code\n        ? state.hand[1]\n        : state.hand[0];\n    console.log(\"three state\", {\n        isSet,\n        kicker,\n    });\n    if (kicker.value.code >= KingCode)\n        return strongHandAction(state);\n    if (state.phase.code <= RiverPhase.code) {\n        if (hasFlushDrawOrOpenEndedStraight(state.handPlusBoard))\n            return strongHandAction(state);\n    }\n    return riskyHandAction(state);\n}\n","import { getPairs, isOneCardFlushOrStraightPossible } from \"../aiUtils\";\nimport { strongHandAction, weakHandAction } from \"./handActions\";\nimport { highCardAction } from \"./highCardAction\";\nimport { pairActionIgnoringBoardPair } from \"./pairAction\";\nexport function twoPairAction(state) {\n    const boardPairs = getPairs(state.board);\n    if (boardPairs.length !== 0) {\n        if (boardPairs.length == 1)\n            return pairActionIgnoringBoardPair(state);\n        else\n            return highCardAction(state);\n    }\n    if (isOneCardFlushOrStraightPossible(state.board))\n        return weakHandAction(state);\n    return strongHandAction(state);\n}\n","/**\n * Linear interpolation, works like https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html\n */\nexport function lerp(min, max, t) {\n    return min + (max - min) * t;\n}\n","const ProbabilisticActionArgs = {\n    checkFoldProbability: 0,\n    callProbability: 0,\n    minRaiseProbability: 0,\n    halfPotRaiseProbability: 0,\n    // tqPotRaiseProbability: 0,\n    potRaiseProbability: 0,\n    // overbetProbability: 0,\n    allInProbability: 0,\n};\nexport const ProbabilisticActionArgsKeys = Object.keys(ProbabilisticActionArgs).map(key => key);\nconst probabilityToAction = {\n    checkFoldProbability: { type: \"check_or_fold\" },\n    callProbability: { type: \"call\" },\n    minRaiseProbability: { type: \"raise\", raiseAmount: \"min\" },\n    halfPotRaiseProbability: { type: \"raise\", raiseAmount: \"1/2_pot\" },\n    // tqPotRaiseProbability: { type: \"raise\", raiseAmount: \"3/4_pot\" },\n    potRaiseProbability: { type: \"raise\", raiseAmount: \"pot\" },\n    // overbetProbability: { type: \"raise\", raiseAmount: \"overbet\" },\n    allInProbability: { type: \"raise\", raiseAmount: \"all_in\" },\n};\n/**\n * Returs an action chosen randomly according to the probabilities you pass in `args`.\n *\n * Note that if to call is zero then the call probability is forced to zero\n * and that the probabilities are always normalized such that they sum to 1.\n * `args` is not modified in this process.\n *\n * This function logs all info regarding the choice, including a `name` you provide\n * that is very convenient when debugging.\n */\nexport function probabilisticAction(name, state, args) {\n    const copy = Object.assign({}, args);\n    if (state.toCall === 0)\n        copy.callProbability = 0;\n    const normalized = normalize(copy);\n    let random = Math.random();\n    for (const key of ProbabilisticActionArgsKeys) {\n        const probability = normalized[key];\n        if (random < probability) {\n            console.log(`\"probabilistic action (${name})`, {\n                input: args,\n                normalized,\n                random,\n                chosen: probabilityToAction[key],\n            });\n            return probabilityToAction[key];\n        }\n        random -= probability;\n    }\n    return { type: \"check_or_fold\" };\n}\n/**\n * Returns a normalized version of `args` such that the probabilities sum to 1\n */\nfunction normalize(args) {\n    let sum = 0;\n    for (const key of ProbabilisticActionArgsKeys)\n        sum += args[key];\n    for (const key of ProbabilisticActionArgsKeys)\n        args[key] /= sum;\n    return args;\n}\nexport function toCallDependent(state, args) {\n    if (state.toCall > 0)\n        return args.nonZero;\n    return Object.assign(Object.assign({}, args.zero), { callProbability: 0 });\n}\n/**\n * Appends \"-call\" if `state.toCall > 0` and \"-zero\" otherwise\n */\nexport function postfixNameToCall(name, state) {\n    if (state.toCall > 0)\n        return name + \"-call\";\n    else\n        return name + \"-zero\";\n}\n/**\n * This let's you specify directly only check/fold and call probabilities, while allowing you\n * to specify the raise probabilities proportional to whatever is left.\n *\n * This is only useful if you don't know a priori the probability of either check/fold of call,\n * because for instance they are the result of a computation\n * (imagine that you want to fold with a probability based on the amount to call).\n *\n * @example\n * // imagine that you want to code a probabilistic bluff raise\n * // an that state.toCall === 75 and state.prevPhasePot === 100\n * // the following will make you fold 75% of the time\n * // pot raise 25% * 0.8 = 20% of the time\n * // go all in 25% * 0.2 = 5% of the time\n * checkCallBased({\n *     checkFoldProbability: state.toCall / state.prevPhasePot,\n *     remainingPotRaiseShare: 0.8,\n *     remainingAllInShare: 0.2,\n * })\n */\nexport function checkCallBased(args) {\n    const sum = args.callProbability + args.checkFoldProbability;\n    const remaining = Math.max(1 - sum, 0);\n    return {\n        checkFoldProbability: args.checkFoldProbability,\n        callProbability: args.callProbability,\n        minRaiseProbability: remaining * args.remainingMinRaiseShare,\n        halfPotRaiseProbability: remaining * args.remainingHalfPotRaiseShare,\n        potRaiseProbability: remaining * args.remainingPotRaiseShare,\n        allInProbability: remaining * args.remainingAllInShare,\n    };\n}\n/**\n * Returns a copy of `args` where undefined probabilities are set to 0\n */\nexport function zeroFill(args) {\n    for (const key of ProbabilisticActionArgsKeys)\n        if (args[key] == undefined)\n            args[key] = 0;\n    return args;\n}\n/**\n * Returns a copy of `args` where undefined probabilities get an equal share of the remaining probability\n */\nexport function uniformFill(args) {\n    const undefinedCount = countUndefinedActions(args);\n    const definedSum = sumDefinedActions(args);\n    const remainingValue = 1 - definedSum;\n    let fillValue;\n    if (remainingValue <= 0)\n        fillValue = 0;\n    else\n        fillValue = remainingValue / undefinedCount;\n    for (const key of ProbabilisticActionArgsKeys)\n        if (args[key] == undefined)\n            args[key] = fillValue;\n    return args;\n}\nfunction countUndefinedActions(args) {\n    let undefinedCount = 0;\n    for (const key of ProbabilisticActionArgsKeys)\n        if (args[key] == undefined)\n            undefinedCount++;\n    return undefinedCount;\n}\nfunction sumDefinedActions(args) {\n    let sum = 0;\n    for (const key of ProbabilisticActionArgsKeys) {\n        const val = args[key];\n        if (val != undefined)\n            sum += val;\n    }\n    return sum;\n}\n","export const AceCode = 14;\nexport const KingCode = 13;\nexport const QueenCode = 12;\nexport const JackCode = 11;\nexport const LowestStraightAceCode = 1;\nexport const InvalidCardCode = 0;\nexport function cardValueCodeFromName(name) {\n    const parsed = parseInt(name);\n    if (!isNaN(parsed))\n        return parsed;\n    switch (name) {\n        case \"A\":\n            return AceCode;\n        case \"K\":\n            return KingCode;\n        case \"Q\":\n            return QueenCode;\n        case \"J\":\n            return JackCode;\n        default:\n            return InvalidCardCode;\n    }\n}\nexport function isCardValueCodeValid(code) {\n    return code > InvalidCardCode && code <= AceCode;\n}\n","export const HighCardRank = {\n    name: \"high\",\n    code: 0,\n};\nexport const PairRank = {\n    name: \"pair\",\n    code: 1,\n};\nexport const TwoPairRank = {\n    name: \"two_pair\",\n    code: 2,\n};\nexport const ThreeOfKindRank = {\n    name: \"three\",\n    code: 3,\n};\nexport const StraightRank = {\n    name: \"straight\",\n    code: 4,\n};\nexport const FlushRank = {\n    name: \"flush\",\n    code: 5,\n};\nexport const FullHouseRank = {\n    name: \"full\",\n    code: 6,\n};\nexport const FourOfKindRank = {\n    name: \"four\",\n    code: 7,\n};\nexport const StraightFlushRank = {\n    name: \"straight_flush\",\n    code: 8,\n};\nexport const RoyalFlushRank = {\n    name: \"royal_flush\",\n    code: 9,\n};\nexport function parseHandRank(rawRank) {\n    const lowercased = rawRank.toLowerCase();\n    if (lowercased.includes(\"high\"))\n        return HighCardRank;\n    else if (lowercased.includes(\"two\"))\n        return TwoPairRank;\n    else if (lowercased.includes(\"pair\"))\n        return PairRank;\n    else if (lowercased.includes(\"three\"))\n        return ThreeOfKindRank;\n    else if (lowercased.includes(\"flush\")) {\n        if (lowercased.includes(\"strai\"))\n            return StraightFlushRank;\n        else if (lowercased.includes(\"roy\"))\n            return RoyalFlushRank;\n        else\n            return FlushRank;\n    }\n    else if (lowercased.includes(\"strai\"))\n        return StraightRank;\n    else if (lowercased.includes(\"four\"))\n        return FourOfKindRank;\n    else if (lowercased.includes(\"full\"))\n        return FullHouseRank;\n    return HighCardRank;\n}\n","export const PreflopPhase = {\n    name: \"preflop\",\n    code: 0,\n};\nexport const FlopPhase = {\n    name: \"flop\",\n    code: 1,\n};\nexport const TurnPhase = {\n    name: \"turn\",\n    code: 2,\n};\nexport const RiverPhase = {\n    name: \"river\",\n    code: 3,\n};\nexport function getPhaseFromBoardLength(length) {\n    switch (length) {\n        case 0:\n        default:\n            return PreflopPhase;\n        case 3:\n            return FlopPhase;\n        case 4:\n            return TurnPhase;\n        case 5:\n            return RiverPhase;\n    }\n}\n","import { cardValueCodeFromName, isCardValueCodeValid } from \"./cards\";\nimport { parseHandRank } from \"./rank\";\nimport { getPhaseFromBoardLength } from \"./state\";\nexport function isMyTurn() {\n    return document.querySelector(\".action-signal\") !== null;\n}\nexport function parseCard(element) {\n    var _a, _b;\n    if (!element)\n        throw new Error(\"can't parse card from null element\");\n    const rawValue = (_a = element.querySelector(\".value\")) === null || _a === void 0 ? void 0 : _a.textContent;\n    const rawSuit = (_b = element.querySelector(\".suit\")) === null || _b === void 0 ? void 0 : _b.textContent;\n    if (!rawValue || !rawSuit)\n        throw new Error(\"can't find value or suit in card element\");\n    const valueName = rawValue;\n    const valueCode = cardValueCodeFromName(valueName);\n    if (!isCardValueCodeValid(valueCode))\n        throw new Error(\"invalid card value code: \" + rawValue);\n    return {\n        value: {\n            name: valueName,\n            code: valueCode,\n        },\n        suit: rawSuit,\n    };\n}\nexport function getHandCards() {\n    const cards = document.querySelectorAll(\".you-player .card\");\n    try {\n        const firstCard = parseCard(cards[0]);\n        const secondCard = parseCard(cards[1]);\n        return [firstCard, secondCard];\n    }\n    catch (err) {\n        throw new Error(\"error parsing hand cards: \" + err);\n    }\n}\nexport function getBoardCards() {\n    const cards = [...document.querySelectorAll(\".table-cards .card\")];\n    try {\n        return cards.map(parseCard);\n    }\n    catch (err) {\n        throw new Error(\"error parsing board cards: \" + err);\n    }\n}\nexport function getBigBlindValue() {\n    var _a;\n    return parseInt((_a = document.querySelectorAll(\".blind-value .chips-value\")[1].textContent) !== null && _a !== void 0 ? _a : \"\");\n}\nexport function getToCallValue() {\n    var _a;\n    const callText = (_a = document.querySelector(\"button.call\")) === null || _a === void 0 ? void 0 : _a.textContent;\n    if (!callText)\n        return 0;\n    const lowercasedCallText = callText.toLowerCase();\n    if (!lowercasedCallText.includes(\"call\"))\n        return 0;\n    if (!lowercasedCallText.includes(\" \"))\n        return 0;\n    return parseInt(lowercasedCallText.split(\" \")[1]);\n}\nexport function getHandRank() {\n    var _a, _b;\n    const rawRank = (_b = (_a = document.querySelector(\".player-hand-message\")) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : \"\";\n    return parseHandRank(rawRank);\n}\nexport function getPhase() {\n    const boardCardsElements = document.querySelectorAll(\".table-cards .card\");\n    return getPhaseFromBoardLength(boardCardsElements.length);\n}\nexport function getStack() {\n    var _a;\n    const stackText = (_a = document.querySelector(\".table-player.you-player .table-player-stack\")) === null || _a === void 0 ? void 0 : _a.textContent;\n    return parseInt(stackText !== null && stackText !== void 0 ? stackText : \"0\");\n}\nexport function getTotalPot() {\n    var _a;\n    const potText = (_a = document.querySelector(\".table-pot-size .add-on .chips-value\")) === null || _a === void 0 ? void 0 : _a.textContent;\n    return parseInt(potText !== null && potText !== void 0 ? potText : \"0\");\n}\nexport function getPrevPhasePot() {\n    var _a;\n    const prevPotText = (_a = document.querySelector(\".table-pot-size .main-value .chips-value\")) === null || _a === void 0 ? void 0 : _a.textContent;\n    return parseInt(prevPotText !== null && prevPotText !== void 0 ? prevPotText : \"0\");\n}\nexport function getState() {\n    const hand = getHandCards();\n    const board = getBoardCards();\n    return {\n        phase: getPhase(),\n        handRank: getHandRank(),\n        hand,\n        board,\n        handPlusBoard: [...hand, ...board],\n        bigBlind: getBigBlindValue(),\n        stack: getStack(),\n        pot: getTotalPot(),\n        prevPhasePot: getPrevPhasePot(),\n        toCall: getToCallValue(),\n    };\n}\nexport function canCheck() {\n    var _a;\n    return !((_a = document.querySelector(\"button.check\")) === null || _a === void 0 ? void 0 : _a.disabled);\n}\nexport function check() {\n    var _a;\n    (_a = document.querySelector(\"button.check\")) === null || _a === void 0 ? void 0 : _a.click();\n}\nexport function fold() {\n    var _a;\n    (_a = document.querySelector(\"button.fold\")) === null || _a === void 0 ? void 0 : _a.click();\n}\nexport function call() {\n    var _a;\n    (_a = document.querySelector(\"button.call\")) === null || _a === void 0 ? void 0 : _a.click();\n}\nfunction withRaiseMenu(action) {\n    const raiseButton = document.querySelector(\"button.raise\");\n    if (raiseButton.disabled) {\n        call();\n        action();\n        return;\n    }\n    raiseButton.click();\n    setTimeout(() => {\n        var _a;\n        action();\n        (_a = document.querySelector('.raise-controller-form input[type=\"submit\"]')) === null || _a === void 0 ? void 0 : _a.click();\n    }, 100);\n}\nfunction getBetButtons() {\n    const buttons = document.querySelectorAll(\".default-bet-buttons button\");\n    console.log(\"bet buttons\", buttons);\n    return buttons;\n}\nexport function minRaise(callback) {\n    withRaiseMenu(() => {\n        var _a;\n        (_a = getBetButtons()[0]) === null || _a === void 0 ? void 0 : _a.click();\n        callback === null || callback === void 0 ? void 0 : callback();\n    });\n}\nexport function halfPotRaise(callback) {\n    withRaiseMenu(() => {\n        var _a;\n        (_a = getBetButtons()[1]) === null || _a === void 0 ? void 0 : _a.click();\n        callback === null || callback === void 0 ? void 0 : callback();\n    });\n}\nexport function tqPotRaise(callback) {\n    withRaiseMenu(() => {\n        var _a;\n        (_a = getBetButtons()[2]) === null || _a === void 0 ? void 0 : _a.click();\n        callback === null || callback === void 0 ? void 0 : callback();\n    });\n}\nexport function potRaise(callback) {\n    withRaiseMenu(() => {\n        var _a;\n        (_a = getBetButtons()[3]) === null || _a === void 0 ? void 0 : _a.click();\n        callback === null || callback === void 0 ? void 0 : callback();\n    });\n}\nexport function allInRaise(callback) {\n    withRaiseMenu(() => {\n        var _a;\n        (_a = getBetButtons()[4]) === null || _a === void 0 ? void 0 : _a.click();\n        callback === null || callback === void 0 ? void 0 : callback();\n    });\n}\nexport function showHandIfPossible() {\n    var _a;\n    (_a = document.querySelector('button.show-your-hand')) === null || _a === void 0 ? void 0 : _a.click();\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getAction } from \"./ai/ai\";\nimport { getBigBlindValue, getState, isMyTurn, showHandIfPossible } from \"./ui\";\nimport { performAction, sanitizeAction } from \"./action\";\nconst timeoutMs = 500;\nlet botLoopTimeout;\nconsole.log(`\"pokerbot v${chrome.runtime.getManifest().version}\"`);\nfunction startBotLoop() {\n    stopBotLoop();\n    console.log(\"starting bot\");\n    console.log(\"big blind: \" + getBigBlindValue());\n    function botLoop() {\n        if (isMyTurn()) {\n            console.log(\"bot turn\");\n            const state = getState();\n            console.log(\"state: \", state);\n            let action;\n            try {\n                action = getAction(state);\n                console.log(\"bot action:\", action);\n            }\n            catch (err) {\n                action = undefined;\n                console.error(\"bot error:\", err);\n            }\n            const sanitizedAction = sanitizeAction(action, state);\n            console.log(\"sanitized bot action:\", sanitizedAction);\n            performAction(sanitizedAction, () => setTimeout(botLoop, timeoutMs));\n        }\n        else {\n            botLoopTimeout = setTimeout(botLoop, timeoutMs);\n        }\n        showHandIfPossible();\n    }\n    botLoop();\n}\nfunction stopBotLoop() {\n    clearTimeout(botLoopTimeout);\n    botLoopTimeout = undefined;\n}\nchrome.runtime.onMessage.addListener((message, sender, callback) => {\n    switch (message) {\n        case \"start_bot\":\n            startBotLoop();\n            break;\n        case \"kill_bot\":\n            stopBotLoop();\n            break;\n        case \"get_bot_status\":\n            let status = botLoopTimeout === undefined\n                ? \"off\"\n                : \"playing\";\n            callback(status);\n            break;\n    }\n});\n"],"names":[],"sourceRoot":""}